<link rel="import" href="../taaabs-trace-timeline-scroller/taaabs-trace-timeline-scroller.html">
<link rel="import" href="../taaabs-trace-timeline/taaabs-trace-timeline.html">
<link rel="import" href="../paper-progress/paper-progress.html">
<link rel="import" href="../taaabs-themes/taaabs-theme.html">

<!--
`<taaabs-trace-timeline-container>` is a graphical elements that displays a timeline and its ruler for a kTBS trace.

In typical use, just insert a `<taaabs-trace-timeline-container>`, and set the traceUri.
TODO: Retrieve the trace with only the traceUri.
TODO: Flex Width & Height
-->
<dom-module id="taaabs-trace-timeline-container">
  <template>
    <style include="taaabs-theme"></style>
    <style is="custom-style">
      :host {
        display: flex;
        width: 100%;
        flex: 1;
        padding: 0px;
      }
      #progress {
        width: 100%;
        height: 10px;
        --paper-progress-active-color: var(--paper-blue-500);
        --paper-progress-indeterminate-cycle-duration: 5s;
      }
      #background-progress {
        width: 100%;
        height: 10px;
        --paper-progress-transition-timing-function: ease;
        --paper-progress-transition-duration: 0.25s;
        --paper-progress-active-color: var(--paper-blue-300);

      }
    </style>
    <div class="flex-vertical flexchild">
      <taaabs-trace-timeline class="flexchild" id="timeline"></taaabs-trace-timeline>
      <taaabs-trace-timeline-scroller id="scroller" style="height: 65px;"></taaabs-trace-timeline-scroller>
      <paper-progress id="progress" indeterminate disabled></paper-progress>
      <paper-progress id="background-progress" min="0" max="100" value="0"></paper-progress>
    </div>
  </template>
  <script>
    Polymer({
      is: 'taaabs-trace-timeline-container',

      properties: {

        /**
         * The trace.
         *
         * @attribute trace
         * @type Object
         */
        trace: {
          type: Object,
          value: null
        },

        /**
         * The trace URI.
         *
         * @attribute traceUri
         * @type String
         */
        traceUri: {
          type: String,
          value: null
        },

        /**
         * The trace stats.
         *
         * @attribute traceStats
         * @type String
         */
        traceStats: {
          type: String,
          value: null
        },

        /**
         * Begin time of the current interval.
         *
         * @attribute _currentBegin
         * @type Number
         */
        _currentBegin: {
          type: Number,
          value: 0
        },

        /**
         * End time of the current interval.
         *
         * @attribute _currentEnd
         * @type Number
         */
        _currentEnd: {
          type: Number,
          value: 0
        },

        /**
         * Either 'FIRST', 'BEFORE' or 'AFTER'.
         *
         * @attribute _downloadType
         * @type String
         */
        _downloadType: {
         type: String,
         value: ""
        },

        /**
         * True if `timeline-scroller-new-bounds` is already listened. False otherwise.
         *
         * @attribute _isEventListened
         * @type Boolean
         */
        _isEventListened: {
         type: Boolean,
         value: false
        },

        /**
         * List of the loading process waiting to be launched.
         *
         * @attribute _loadingProcessList
         * @type Array
         */
        _loadingProcessList: {
         type: Array,
         value: []
        },

        /**
         * List of the obsels currently downloaded.
         *
         * @attribute _loadingObselsList
         * @type Array
         */
        _loadingObselsList: {
          type: Array,
          value: []
        },

        /**
         * Max time ever downloaded.
         *
         * @attribute _maxEnd
         * @type Number
         */
        _maxEnd: {
          type: Number,
          value: Number.NEGATIVE_INFINITY
        },

        /**
         * Minimum time ever downloaded.
         *
         * @attribute _minBegin
         * @type Number
         */
        _minBegin: {
          type: Number,
          value: Number.POSITIVE_INFINITY
        },

        /**
         * List of the obsels.
         *
         * @attribute _obselsList
         * @type Array
         */
        _obselsList: {
          type: Array,
          value: []
        },

        /**
         * End of the second part of obsels to download.
         *
         * @attribute _secondPartEnd
         * @type Number
         */
        _secondPartEnd: {
          type: Number,
          value: 0
        },


        /**
        * TRYHARD *
        */

        _downloadBuffer: {
          type: Array,
          value: []
        },

        _downloadPriority: {
          type: Array,
          value: []
        },

        _obselsCount: {
          type: Number,
          value: 0
        }


      },

      attached: function() {
        if(!this._isEventListened){
          this.$.scroller.addEventListener('timeline-scroller-new-bounds', this._onTimelineScrollerNewBounds.bind(this));
          this.$.scroller.addEventListener('timeline-scroller-shift', this._onTimelineScrollerShift.bind(this));
          this.$.timeline.addEventListener('timeline-interval-selected', this._onTimelineIntervalSelected.bind(this));
          this.set('_isEventListened', true);
        }
      },

      ready: function() {},

      updateTimeline: function(){
        this.$.timeline.redrawObsels(this._applyStyleOnObsels(this._getObselsForCurrentBounds()));
      },

      /**
       * Reset the timeline and the scroller.
       *
       * @method refresh
       */
      refresh: function(){
        // Get the begin and end of the trace.
        var b = this.traceStats['stats:minTime'];
        var e = this.traceStats['stats:maxTime'];
        this.set('_currentBegin', b);
        this.set('_currentEnd',   e);
        // Set the scroller vars.
        this.$.scroller.init(b, e);
        // Set the timeline vars
        this.$.timeline.setTemporalBounds(b, e);
        this.$.timeline.initVisu();
        // While the timeline width isn't set, we wait.
        // Then, we start the passiv download
        var interval = setInterval(function(){
          if(this.$.timeline._width !== 0){
            clearInterval(interval);
            this._startPassiveDownload();
          }
        }.bind(this), 500);
      },

      _startPassiveDownload: function(){
        // Get the begin/end of the trace.
        // Calculate the period for each obsel column
        var b = this.traceStats['stats:minTime'];
        var e = this.traceStats['stats:maxTime'];
        var c = this.$.timeline._width / (this.$.timeline._obselWidth + 2);
        var period = Math.ceil((e-b) / c);
        this.set('_downloadPeriod', period);
        // Create a download buffer for each column
        for(var i = 0 ; i < c ; i++){
          this.push('_downloadBuffer', {
            'b': b+(period*i),
            'e': b+(period*i)+period,
            'isOver': false,
            'obsels': []
          });
        }
        // Start the download
        this._launchDownload();
      },

      _launchDownload: function(){
        // If we don't have priority downloads, we download every obsel in background.
        if(this._downloadPriority.length === 0){
          this.$.progress.set('disable', true);
          // Show the passive progress bar.
          var i = 0;
          // If the first download campaign is over, we look for the column not complete yet.
          // Otherwise, we look for the column visited yet.
          // When the first campaign is over , we set `_firstDownloadDone` to true, and we _launchDownload again.
          if(this._firstDownloadDone){
            while(i < this._downloadBuffer.length &&
              this._downloadBuffer[i].isOver) i++;
          }
          else{
            while(i < this._downloadBuffer.length &&
              ( this._downloadBuffer[i].isOver || this._downloadBuffer[i].obsels.length !== 0 ))
              i++;
            if(i >= this._downloadBuffer.length){
              this._firstDownloadDone = true;
              this._launchDownload();
            }
          }
          // If we havan't download everyhing yet, well, we get the obsels...
          if(i < this._downloadBuffer.length){
            this.set('_downloadCurrentBufferIndex', i);
            // Set time
            var b = this.traceStats['stats:minTime'];
            b += (i * this._downloadPeriod);
            // Set obsel
            var uri = null;
            if(this._downloadBuffer[i].obsels.length > 0) uri = this._downloadBuffer[i].obsels[this._downloadBuffer[i].obsels.length - 1]['@id'];
            if(this._firstDownloadDone)
              this._downloadObsels(b, b + this._downloadPeriod - 1, 100, uri );
            else
              this._downloadObsels(b, null, 30, uri );
          }
        }
        else{
          this.$.progress.set('disable', false);
          var i = this.splice('_downloadPriority', 0, 1);
          while(this._downloadBuffer[i].isOver)
            i = this.splice('_downloadPriority', 0, 1);
            this.set('_downloadCurrentBufferIndex', i);
            // Set time
            var b = this.traceStats['stats:minTime'];
            b += (i * this._downloadPeriod);
            // Set obsel
            var uri = null;
            if(this._downloadBuffer[i].obsels.length > 0) uri = this._downloadBuffer[i].obsels[this._downloadBuffer[i].obsels.length - 1]['@id'];
            this._downloadObsels(b, b + this._downloadPeriod - 1, 100, uri );
        }
      },

      /**
       * Set the symbol of a list of obsels according to the `stylesheet`.
       * TODO: Set default symbol.
       *
       * @param {!required} list (Array) The obsels.
       *
       * @method _applyStyleOnObsels
       */
      _applyStyleOnObsels: function(list){
        var result = [];
        var r = this.stylesheet.rules;
        var t = [];
        // For every obsels, sort the list of rule following :
        // number of type prior number of attribute prior index of rule.
        for(var i = 0; i < list.length; i++){
          t = [];
          var o = {};
          for(var j = 0; j < r.length; j++){
            o = {'id': j.id, 'i': j, 't': 0, 'a': 0};
            var tan = 0;
            for(var k = 0; k < r[j].rules.length; k++){
              var doNotMatch = false;
              if(r[j].rules[k].type !== ""){
                if(list[i]['@type'] === r[j].rules[k].type.replace(this.trace.model_uri+"#", 'm:')){
                  o.t = 1;
                }
                else{
                  doNotMatch = true;
                }
              }
              if(!doNotMatch){
                for(var l = 0; l < r[j].rules[k].attributes.length; l++){
                  if(list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')] !== undefined &&
                  list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')] !== null){
                    switch(r[j].rules[k].attributes[l].operator){
                      case "==":
                        if(list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')] == r[j].rules[k].attributes[l].value){
                          o.a += 1;
                        }
                        else doNotMatch = true;
                      break;
                      case ">":
                        if(Number(list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')]) > Number(r[j].rules[k].attributes[l].value)){
                          o.a += 1;
                        }
                        else doNotMatch = true;
                      break;
                      case ">=":
                        if(Number(list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')]) >= Number(r[j].rules[k].attributes[l].value)){
                          o.a += 1;
                        }
                        else doNotMatch = true;
                      break;
                      case "<":
                        if(Number(list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')]) < Number(r[j].rules[k].attributes[l].value)){
                          o.a += 1;
                        }
                        else doNotMatch = true;
                      break;
                      case "<=":
                        if(Number(list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')]) <= Number(r[j].rules[k].attributes[l].value)){
                          o.a += 1;
                        }
                        else doNotMatch = true;
                      break;
                    }
                  }
                }
              }
              if(!doNotMatch) t.push(o);
              else{
                t.push({'id': j.id, 'i': j, 't': 0, 'a': 0});
              }
            }
          }
          t.sort(function(a, b) {
            if(a.t === b.t){
              if(a.a === b.a){
                if(a.i > b.i){
                  return 1;
                }
                else{
                  return -1;
                }
              }
              else if(a.a > b.a){
                return -1;
              }
              else{
                return 1;
              }
            }
            else if(a.t > b.t){
              return -1;
            }
            else{
              return 1;
            }
          });
          if(t[0].a !== 0 || t[0].t !== 0)[
            result.push({
              'obsel': list[i],
              'symbol': r[t[0].i].symbol,
              'visible': r[t[0].i].visible
            })
          ]
        }
        return result;
      },


      _sortObselsInBuffer: function(obs, overflow){
        var index = this.get('_downloadCurrentBufferIndex');
        for(var i = 0; i < obs.length; i++){
          if(obs[i].begin >= this._downloadBuffer[index].b && obs[i].end < this._downloadBuffer[index].e){
            this._downloadBuffer[this._downloadCurrentBufferIndex].obsels.push(obs[i]);
          }
          else{
            i--;
            this._downloadBuffer[index].isOver = true;
            console.log('index '+index+' is over');
            index++;
          }
          if(index > this._downloadBuffer.length){
            console.log('error : Obsel couldnt fit in any buffer');
            i = obs.length;
          }
        }
        if(index !== this.get('_downloadCurrentBufferIndex')){
          if(overflow) this._downloadBuffer[index].isOver = true;
          if(this._downloadBuffer[index].obsels.length > 30) index++;
          this.set('_downloadCurrentBufferIndex', index);
        }
        else{
          if(overflow) this._downloadBuffer[index].isOver = true;
          this.set('_downloadCurrentBufferIndex', index+1);
        }
        console.log('new index : '+this._downloadCurrentBufferIndex);
      },

      /**
       * Download the obsels.
       *
       * @param {!required} start (Number) The begin time of the interval to download.
       * @param {!required} stop (Number) The end time of the interval to download.
       *
       * @method _downloadObsels
       */
      _downloadObsels: function(start, stop, limit, uri){
        limit = limit || 100;
         var minb  = (start) ? 'minb='+start  : '';
         var maxe  = (stop)  ? '&maxe='+stop  : '';
         var after = (uri)   ? '&after='+uri   : '';
         var request = this.traceUri + '@obsels?'+minb+after+maxe+'&limit='+limit;
         var XMLReq = new XMLHttpRequest();
         XMLReq.open("GET", request);
         XMLReq.setRequestHeader('Content-Type', 'application/json');
         XMLReq.setRequestHeader('Accept', 'application/ld+json');
         XMLReq.withCredentials = true;
         XMLReq.onreadystatechange = function() {
           if (XMLReq.readyState === 4) {
             if (XMLReq.status === 200 || XMLReq.status === 201 || XMLReq.status === 304) {
               var obs = (JSON.parse(XMLReq.response)).obsels;
               console.log(obs);
              // OLD VERSION THAT GET A SINGLE COLUMN EACH TIME
              //  for(var i = 0; i < obs.length; i++){
              //    this._downloadBuffer[this._downloadCurrentBufferIndex].obsels.push(obs[i]);
              //  }
              //  if(obs.length < 100){
              //    console.log('column over');
              //    this._downloadBuffer[this._downloadCurrentBufferIndex].isOver = true;
              //  }
               this._sortObselsInBuffer(obs, (obs.length < limit));
               this.set('_obselsCount', this.get('_obselsCount') + obs.length);
               var progress = Math.floor( this.get('_obselsCount') / this.traceStats['stats:obselCount'] * 100 );
               this.$['background-progress'].set('value', progress);
               this._launchDownload();
               this.$.timeline.addObsels(this._applyStyleOnObsels(obs));
             } else {
               console.log(XMLReq);
             }
           }
         }.bind(this);
         XMLReq.onerror = function(err) {
           console.log(err);
         };
         XMLReq.send(null);
      },

       /**
        * Download the obsels.
        *
        * @param {!required} begin (Number) The begin time of the selected interval.
        * @param {!required} end (Number) The end time of the selected interval.
        *
        * @method _loadTimelineScrollerNewBounds
        */
       _loadTimelineScrollerNewBounds: function(process){
         this.set('_currentBegin', process.overall_begin);
         this.set('_currentEnd'  , process.overall_end  );
         this.$.timeline.setTemporalBounds(this._currentBegin, this._currentEnd);
         // If the chosen interval have not been downloaded yet, we download it.
         // Otherwise, we just display the obsels downloaded.
         if(this._obselsList.length === 0){
           this.$.progress.set('disabled', false);
           this.set('_downloadType', 'FIRST');
           this._downloadObsels(this._currentBegin, this._currentEnd);
         }
         else{
           if(this._currentBegin < this._minBegin){
             this.$.progress.set('disabled', false);
             this.set('_downloadType', 'BEFORE');
             this._downloadObsels(this._currentBegin, this._minBegin);
           }
           else if(this._currentEnd > this._maxEnd){
             this.$.progress.set('disabled', false);
             this.set('_downloadType', 'AFTER');
             this._downloadObsels(this._maxEnd, this._currentEnd);
           }
           else{
             this._launchLoadingProcess();
           }
           var obs = [];
           for(var i = 0; i < this._obselsList.length; i++){
             // TODO Get this more opti
             if(this._obselsList[i].begin >= this._currentBegin && this._obselsList[i].end <= this._currentEnd){
               obs.push(this._obselsList[i])
             }
           }
           this.$.timeline.addObsels(this._applyStyleOnObsels(obs));
         }
       },

       _loadTimelineIntervalSelected: function(process){
         this.set('_currentBegin', process.overall_begin);
         this.set('_currentEnd'  , process.overall_end  );
         this.$.timeline.setTemporalBounds(this._currentBegin, this._currentEnd);
         this.$.timeline.addObsels(this._applyStyleOnObsels(this._getObselsForCurrentBounds()));
         this.$.scroller.updateVisu(this._currentBegin, this._currentEnd);
         this._launchLoadingProcess();
       },


       _getObselsForCurrentBounds: function(b, e){
         b = b || this._currentBegin;
         e = e || this._currentEnd;
         var ib = Math.floor((b-this.traceStats['stats:minTime'])/this._downloadPeriod);
         var eb = Math.ceil((e-this.traceStats['stats:minTime']-this._downloadPeriod+1)/this._downloadPeriod);
         var obs = [];
         for(var i = ib; i <= eb; i++){
           for(var j = 0; j < this._downloadBuffer[i].obsels.length; j++){
             if(this._downloadBuffer[i].obsels[j].begin >= b && this._downloadBuffer[i].obsels[j].end <= e){
               obs.push(this._downloadBuffer[i].obsels[j])
             }
           }
         }
         return obs;
       },

       _loadTimelineScrollerShift: function(process){
         // Set the new bounds
         this.set('_currentBegin', process.overall_begin);
         this.set('_currentEnd',   process.overall_end);
         // Create the process var
         var b = process.shift_begin;
         var e = process.shift_end;
         var d = process.direction;
         // True if we already loaded the obsels. False otherwise.
         var already_loaded =
           ((d === 'left' && this._currentEnd < this._maxEnd) ||
           (d === 'right' && this._currentBegin > this._minBegin));
         // Load the enw obsels if necessary.
         if(already_loaded){
          this.$.timeline.shiftObsels(this._applyStyleOnObsels(this._getObselsForCurrentBounds(b, e)), d);
          this._launchLoadingProcess();
         }
         else{
          this.$.progress.set('disabled', false);
          var start = (d === 'left') ? this._maxEnd : this._currentBegin;
          var end   = (d === 'left') ? this._currentEnd : this._minBegin;
          var type  = (d === 'left') ? 'AFTER' : 'BEFORE';
          this.$.timeline.shiftObsels([], d);
          this.set('_downloadType', type);
          this._downloadObsels(start, end);
         }
       },

       /**
        * .
        *
        * @param {!required} evt {String} The `timeline-scoller-shift` event.
        *
        * @method _onTimelineScrollerShift
        */
      _onTimelineScrollerShift: function(evt) {
        // Push the new loading process in the waiting line.
        this.push('_loadingProcessList', {
          'type'         : 'timeline-scoller-shift',
          'overall_begin': evt.detail.b,
          'overall_end'  : evt.detail.e,
          'shift_begin'  : evt.detail.nb,
          'shift_end'    : evt.detail.ne,
          'direction'    : evt.detail.d
        });
        // Launch the download process.
        if(!this._isProcessLaunched){
          this.set('_isProcessLaunched', true);
          this._launchLoadingProcess();
        }
      },

      _isNotDownloaded: function(b, e){
        var ib = Math.floor((b-this.traceStats['stats:minTime'])/this._downloadPeriod);
        var eb = Math.ceil((e-this.traceStats['stats:minTime']-this._downloadPeriod+1)/this._downloadPeriod);
        var result = [];
        for(var i = ib; i <= eb; i++){
          if(!this._downloadBuffer[i].isOver)result.push(i);
        }
        return result;
      },

      /**
       * Calls `_onScrollerNewBounds`.
       *
       * @param {!required} evt (Event) The `timeline-scroller-new-bounds` event.
       *
       * @method _onTimelineScrollerNewBounds
       */
      _onTimelineScrollerNewBounds: function(evt){
        var b = ( evt.detail.b < this.traceStats['stats:minTime']) ? this.traceStats['stats:minTime'] : evt.detail.b;
        var e = ( evt.detail.e > this.traceStats['stats:maxTime']) ? this.traceStats['stats:maxTime'] : evt.detail.e;
        this.set('_currentBegin',b);
        this.set('_currentEnd',  e);
        if(this._isNotDownloaded(b,e).length === 0){
          this.$.timeline.setTemporalBounds(b,e);
          this.$.timeline.addObsels(this._applyStyleOnObsels(this._getObselsForCurrentBounds()));
        }
        else{
          this.set('_downloadPriority', this._isNotDownloaded(b,e));
        }
      },

      _onTimelineIntervalSelected: function(evt){
        var b = ( evt.detail.b < this.traceStats['stats:minTime']) ? this.traceStats['stats:minTime'] : evt.detail.b;
        var e = ( evt.detail.e > this.traceStats['stats:maxTime']) ? this.traceStats['stats:maxTime'] : evt.detail.e;
        this.set('_currentBegin',b);
        this.set('_currentEnd',  e);
        if(this._isDownloaded(b,e).length === 0){
          this.$.timeline.addObsels(this._applyStyleOnObsels(this._getObselsForCurrentBounds()));
        }
        else{
          this.set('_downloadPriority', this._isNotDownloaded(b,e));
        }
      }

    });
  </script>
</dom-module>
