<link rel="import" href="../taaabs-trace-timeline-scroller/taaabs-trace-timeline-scroller.html">
<link rel="import" href="../taaabs-trace-timeline/taaabs-trace-timeline.html">
<link rel="import" href="../paper-progress/paper-progress.html">


<!--
`<taaabs-trace-timeline-container>` is a graphical elements that displays a timeline and its ruler for a kTBS trace.

In typical use, just insert a `<taaabs-trace-timeline-container>`, and set the traceUri.
TODO: Retrieve the trace with only the traceUri.
TODO: Flex Width & Height
-->
<dom-module id="taaabs-trace-timeline-container">
  <template>
    <style is="custom-style">
      :host {
        display: block;
      }
      #progress {
        width: 1400px;
        height: 10px;
        --paper-progress-active-color: var(--paper-blue-500);
        --paper-progress-indeterminate-cycle-duration: 5s;
      }
    </style>
    <taaabs-trace-timeline id="timeline" style="height: 315px; width: 1400px"></taaabs-trace-timeline>
    <taaabs-trace-timeline-scroller id="scroller" style="height: 65px; width: 1400px;"></taaabs-trace-timeline-scroller>
    <paper-progress id="progress" indeterminate disabled></paper-progress>
  </template>
  <script>
    Polymer({
      is: 'taaabs-trace-timeline-container',

      properties: {

        /**
         * The trace.
         *
         * @attribute trace
         * @type Object
         */
        trace: {
          type: Object,
          value: null
        },

        /**
         * The trace URI.
         *
         * @attribute traceUri
         * @type String
         */
        traceUri: {
          type: String,
          value: null
        },

        /**
         * The trace stats.
         *
         * @attribute traceStats
         * @type String
         */
        traceStats: {
          type: String,
          value: null
        },

        /**
         * Begin time of the current interval.
         *
         * @attribute _currentBegin
         * @type Number
         */
        _currentBegin: {
          type: Number,
          value: 0
        },

        /**
         * End time of the current interval.
         *
         * @attribute _currentEnd
         * @type Number
         */
        _currentEnd: {
          type: Number,
          value: 0
        },

        /**
         * Either 'FIRST', 'BEFORE' or 'AFTER'.
         *
         * @attribute _downloadType
         * @type String
         */
        _downloadType: {
         type: String,
         value: ""
        },

        /**
         * True if `timeline-scroller-new-bounds` is already listened. False otherwise.
         *
         * @attribute _isEventListened
         * @type Boolean
         */
        _isEventListened: {
         type: Boolean,
         value: false
        },

        /**
         * List of the loading process waiting to be launched.
         *
         * @attribute _loadingProcessList
         * @type Array
         */
        _loadingProcessList: {
         type: Array,
         value: []
        },

        /**
         * List of the obsels currently downloaded.
         *
         * @attribute _loadingObselsList
         * @type Array
         */
        _loadingObselsList: {
          type: Array,
          value: []
        },

        /**
         * Max time ever downloaded.
         *
         * @attribute _maxEnd
         * @type Number
         */
        _maxEnd: {
          type: Number,
          value: Number.NEGATIVE_INFINITY
        },

        /**
         * Minimum time ever downloaded.
         *
         * @attribute _minBegin
         * @type Number
         */
        _minBegin: {
          type: Number,
          value: Number.POSITIVE_INFINITY
        },

        /**
         * List of the obsels.
         *
         * @attribute _obselsList
         * @type Array
         */
        _obselsList: {
          type: Array,
          value: []
        },

        /**
         * End of the second part of obsels to download.
         *
         * @attribute _secondPartEnd
         * @type Number
         */
        _secondPartEnd: {
          type: Number,
          value: 0
        }
      },

      attached: function() {
        if(!this._isEventListened){
          this.$.scroller.addEventListener('timeline-scroller-new-bounds', this._onTimelineScrollerNewBounds.bind(this));
          this.$.scroller.addEventListener('timeline-scroller-shift', this._onTimelineScrollerShift.bind(this));
          this.$.timeline.addEventListener('timeline-interval-selected', this._onTimelineIntervalSelected.bind(this));
          this.set('_isEventListened', true);
        }
      },

      ready: function() {},

      updateTimeline: function(){
        console.log(this.stylesheet);
        this.$.timeline.redrawObsels(this._applyStyleOnObsels(this._getObselsForCurrentBounds()));
      },

      /**
       * Reset the timeline and the scroller.
       *
       * @method refresh
       */
      refresh: function(){
        // Get the begin and end of the trace.
        var b = this.traceStats['stats:minTime'];
        var e = this.traceStats['stats:maxTime'];
        // Set the scroller vars.
        this.$.scroller.set('begin', b);
        this.$.scroller.set('end', e);
        this.$.scroller.initVisu();
        // Set the timeline vars
        this.$.timeline.initVisu();
      },

      /**
       * Set the symbol of a list of obsels according to the `stylesheet`.
       * TODO: Set default symbol.
       *
       * @param {!required} list (Array) The obsels.
       *
       * @method _applyStyleOnObsels
       */
      _applyStyleOnObsels: function(list){
        var result = [];
        var r = this.stylesheet.rules;
        var t = [];
        // For every obsels, sort the list of rule following :
        // number of type prior number of attribute prior index of rule.
        for(var i = 0; i < list.length; i++){
          t = [];
          var o = {};
          for(var j = 0; j < r.length; j++){
            o = {'id': j.id, 'i': j, 't': 0, 'a': 0};
            var tan = 0;
            for(var k = 0; k < r[j].rules.length; k++){
              if(list[i]['@type'] === r[j].rules[k].type.replace(this.trace.model_uri+"#", 'm:')){
                o.t = 1;
              }
              for(var l = 0; l < r[j].rules[k].attributes.length; l++){
                console.log(r[j].rules[k].attributes[l]);
                console.log(r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:'));
                console.log(list[i]);
                console.log(list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')]);
                if(list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')] !== undefined &&
                list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')] !== null){
                  switch(r[j].rules[k].attributes[l].operator){
                    case "==":
                      if(list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')] == r[j].rules[k].attributes[l].value){
                        o.a += 1;
                      }
                    break;
                    case ">":
                      if(Number(list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')]) > Number(r[j].rules[k].attributes[l].value)){
                        o.a += 1;
                      }
                    break;
                    case ">=":
                      if(Number(list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')]) >= Number(r[j].rules[k].attributes[l].value)){
                        o.a += 1;
                      }
                    break;
                    case "<":
                      if(Number(list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')]) < Number(r[j].rules[k].attributes[l].value)){
                        o.a += 1;
                      }
                    break;
                    case "<=":
                      if(Number(list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')]) <= Number(r[j].rules[k].attributes[l].value)){
                        o.a += 1;
                      }
                    break;
                  }
                }
              }
            }
            t.push(o);
          }
          t.sort(function(a, b) {
            if(a.t === b.t){
              if(a.a === b.a){
                if(a.i > b.i){
                  return 1;
                }
                else{
                  return -1;
                }
              }
              else if(a.a > b.a){
                return -1;
              }
              else{
                return 1;
              }
            }
            else if(a.t > b.t){
              return -1;
            }
            else{
              return 1;
            }
          });
          if(t[0].a !== 0 || t[0].t !== 0)[
            result.push({
              'obsel': list[i],
              'symbol': r[t[0].i].symbol,
              'visible': r[t[0].i].visible
            })
          ]
        }
        return result;
      },

      /**
       * Download the obsels.
       *
       * @param {!required} start (Number) The begin time of the interval to download.
       * @param {!required} stop (Number) The end time of the interval to download.
       *
       * @method _downloadObsels
       */
      _downloadObsels: function(start, stop, limit, uri, _resolve, _reject){
         limit = limit || 100;
         var minb  = (start) ? 'minb='+start  : '';
         var after = (uri)   ? 'after='+uri   : '';
         var maxe  = (stop)  ? '&maxe='+stop  : '';
         var request = this.traceUri + '@obsels?'+minb+after+maxe+'&limit='+limit;
         var XMLReq = new XMLHttpRequest();
         XMLReq.open("GET", request);
         XMLReq.setRequestHeader('Content-Type', 'application/json');
         XMLReq.setRequestHeader('Accept', 'application/ld+json');
         XMLReq.withCredentials = true;
         XMLReq.onreadystatechange = function() {
           if (XMLReq.readyState === 4) {
             if (XMLReq.status === 200 || XMLReq.status === 201 || XMLReq.status === 304) {
               var obs = (JSON.parse(XMLReq.response)).obsels;
               for(var i = 0; i < obs.length; i++){
                 this.push('_loadingObselsList', obs[i]);
               }
               this.$.timeline.addObsels(this._applyStyleOnObsels(obs));
               if(obs.length > 0){
                 this._downloadObsels( null, stop, limit, obs[obs.length - 1]['@id']);
               } else {
                 this._handleDownloadResults();
               }
             } else {
               _reject(XMLReq);
             }
           }
         }.bind(this);
         XMLReq.onerror = function(err) {
           reject(err);
         };
         XMLReq.send(null);

       },

       /**
        * Called after a download, to fill `_obselsList`
        *
        * @method _handleDownloadResults
        */
       _handleDownloadResults: function(){
         if(this._downloadType === 'FIRST'){
           this.set('_obselsList', this.get('_loadingObselsList'));
           this.set('_loadingObselsList', []);
           this.set('_minBegin', this.get('_currentBegin'));
           this.set('_maxEnd',   this.get('_currentEnd'));
           this.$.progress.set('disabled', true);
           this._launchLoadingProcess();
         }
         else if(this._downloadType === 'BEFORE'){
           this.set('_obselsList', this.get('_loadingObselsList').concat(this.get('_obselsList')));
           this.set('_loadingObselsList', []);
           this.set('_minBegin', this.get('_currentBegin'));
           if(this._currentEnd > this._maxEnd){
             this.set('_downloadType', 'AFTER');
             this._downloadObsels(this._maxEnd, this._currentEnd);
           }
           else{
             this.$.progress.set('disabled', true);
             this._launchLoadingProcess();
           }
         }
         else if(this._downloadType === 'AFTER'){
           this.set('_maxEnd', this.get('_currentEnd'));
           this.set('_obselsList', (this.get('_obselsList')).concat(this.get('_loadingObselsList')));
           this.set('_loadingObselsList', []);
           this.$.progress.set('disabled', true);
           this._launchLoadingProcess();
         }
       },

       /**
        * Download the obsels.
        *
        * @param {!required} begin (Number) The begin time of the selected interval.
        * @param {!required} end (Number) The end time of the selected interval.
        *
        * @method _loadTimelineScrollerNewBounds
        */
       _loadTimelineScrollerNewBounds: function(process){
         this.set('_currentBegin', process.overall_begin);
         this.set('_currentEnd'  , process.overall_end  );
         this.$.timeline.setTemporalBounds(this._currentBegin, this._currentEnd);
         // If the chosen interval have not been downloaded yet, we download it.
         // Otherwise, we just display the obsels downloaded.
         if(this._obselsList.length === 0){
           this.$.progress.set('disabled', false);
           this.set('_downloadType', 'FIRST');
           this._downloadObsels(this._currentBegin, this._currentEnd);
         }
         else{
           if(this._currentBegin < this._minBegin){
             this.$.progress.set('disabled', false);
             this.set('_downloadType', 'BEFORE');
             this._downloadObsels(this._currentBegin, this._minBegin);
           }
           else if(this._currentEnd > this._maxEnd){
             this.$.progress.set('disabled', false);
             this.set('_downloadType', 'AFTER');
             this._downloadObsels(this._maxEnd, this._currentEnd);
           }
           else{
             this._launchLoadingProcess();
           }
           var obs = [];
           for(var i = 0; i < this._obselsList.length; i++){
             // TODO Get this more opti
             if(this._obselsList[i].begin >= this._currentBegin && this._obselsList[i].end <= this._currentEnd){
               obs.push(this._obselsList[i])
             }
           }
           this.$.timeline.addObsels(this._applyStyleOnObsels(obs));
         }
       },

       _loadTimelineIntervalSelected: function(process){
         this.set('_currentBegin', process.overall_begin);
         this.set('_currentEnd'  , process.overall_end  );
         this.$.timeline.setTemporalBounds(this._currentBegin, this._currentEnd);
         this.$.timeline.addObsels(this._applyStyleOnObsels(this._getObselsForCurrentBounds()));
         this.$.scroller.updateVisu(this._currentBegin, this._currentEnd);
         this._launchLoadingProcess();
       },

       _launchLoadingProcess: function(){
         console.log('_launchLoadingProcess : ');
         if(this._loadingProcessList.length > 0){
           var p = this.splice('_loadingProcessList', 0, 1)[0];
           console.log('   p : ');
           console.log(p);
           switch(p.type){
             case 'timeline-scoller-shift':
              this._loadTimelineScrollerShift(p);
             break;
             case 'timeline-scroller-new-bounds':
              this._loadTimelineScrollerNewBounds(p);
             break;
             case 'timeline-interval-selected':
              this._loadTimelineIntervalSelected(p);
             break;
           }
         }
         else{
           console.log('end launching');
           this.set('_isProcessLaunched', false);
         }
       },


       _getObselsForCurrentBounds: function(b, e){
         b = b || this._currentBegin;
         e = e || this._currentEnd;
         var obs = [];
         for(var i = 0; i < this._obselsList.length; i++){
           // TODO Get this more opti.
           if(this._obselsList[i].begin >= b && this._obselsList[i].end <= e){
             obs.push(this._obselsList[i])
           }
         }
         return obs;
       },

       _loadTimelineScrollerShift: function(process){
         // Set the new bounds
         this.set('_currentBegin', process.overall_begin);
         this.set('_currentEnd',   process.overall_end);
         // Create the process var
         var b = process.shift_begin;
         var e = process.shift_end;
         var d = process.direction;
         // True if we already loaded the obsels. False otherwise.
         var already_loaded =
           ((d === 'left' && this._currentEnd < this._maxEnd) ||
           (d === 'right' && this._currentBegin > this._minBegin));
         // Load the enw obsels if necessary.
         if(already_loaded){
          this.$.timeline.shiftObsels(this._applyStyleOnObsels(this._getObselsForCurrentBounds(b, e)), d);
          this._launchLoadingProcess();
         }
         else{
          this.$.progress.set('disabled', false);
          var start = (d === 'left') ? this._maxEnd : this._currentBegin;
          var end   = (d === 'left') ? this._currentEnd : this._minBegin;
          var type  = (d === 'left') ? 'AFTER' : 'BEFORE';
          this.$.timeline.shiftObsels([], d);
          this.set('_downloadType', type);
          this._downloadObsels(start, end);
         }
       },

       /**
        * .
        *
        * @param {!required} evt {String} The `timeline-scoller-shift` event.
        *
        * @method _onTimelineScrollerShift
        */
      _onTimelineScrollerShift: function(evt) {
        // Push the new loading process in the waiting line.
        this.push('_loadingProcessList', {
          'type'         : 'timeline-scoller-shift',
          'overall_begin': evt.detail.b,
          'overall_end'  : evt.detail.e,
          'shift_begin'  : evt.detail.nb,
          'shift_end'    : evt.detail.ne,
          'direction'    : evt.detail.d
        });
        // Launch the download process.
        if(!this._isProcessLaunched){
          this.set('_isProcessLaunched', true);
          this._launchLoadingProcess();
        }
      },

      /**
       * Calls `_onScrollerNewBounds`.
       *
       * @param {!required} evt (Event) The `timeline-scroller-new-bounds` event.
       *
       * @method _onTimelineScrollerNewBounds
       */
      _onTimelineScrollerNewBounds: function(evt){
        // Push the new loading process in the waiting line.
        this.push('_loadingProcessList', {
          'type'         : 'timeline-scroller-new-bounds',
          'overall_begin': evt.detail.b,
          'overall_end'  : evt.detail.e
        });
        // Launch the download process.
        if(!this._isProcessLaunched){
          this.set('_isProcessLaunched', true);
          this._launchLoadingProcess();
        }
      },

      _onTimelineIntervalSelected: function(evt){
        // Push the new loading process in the waiting line.
        this.push('_loadingProcessList', {
          'type'         : 'timeline-interval-selected',
          'overall_begin': evt.detail.b,
          'overall_end'  : evt.detail.e
        });
        // Launch the download process.
        if(!this._isProcessLaunched){
          this.set('_isProcessLaunched', true);
          this._launchLoadingProcess();
        }
      }

    });
  </script>
</dom-module>
