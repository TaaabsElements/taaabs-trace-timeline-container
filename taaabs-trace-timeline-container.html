<link rel="import" href="../taaabs-trace-timeline-scroller/taaabs-trace-timeline-scroller.html">
<link rel="import" href="../taaabs-trace-timeline/taaabs-trace-timeline.html">
<link rel="import" href="../paper-progress/paper-progress.html">
<link rel="import" href="../taaabs-themes/taaabs-theme.html">

<!--
`<taaabs-trace-timeline-container>` is a graphical elements that displays a timeline and its ruler for a kTBS trace.

In typical use, just insert a `<taaabs-trace-timeline-container>`, and set the traceUri.
TODO: Retrieve the trace with only the traceUri.
TODO: Flex Width & Height
-->
<dom-module id="taaabs-trace-timeline-container">
  <template>
    <style include="taaabs-theme"></style>
    <style is="custom-style">
      :host {
        display: flex;
        width: 100%;
        flex: 1;
        padding: 0px;
      }
      #progress {
        width: 100%;
        height: 10px;
        --paper-progress-active-color: var(--paper-blue-500);
        --paper-progress-indeterminate-cycle-duration: 5s;
      }
      #background-progress {
        width: 100%;
        height: 10px;
        --paper-progress-transition-timing-function: ease;
        --paper-progress-transition-duration: 0.25s;
        --paper-progress-active-color: var(--paper-blue-300);

      }
    </style>
    <div class="flex-vertical flexchild">
      <taaabs-trace-timeline class="flexchild" id="timeline"></taaabs-trace-timeline>
      <taaabs-trace-timeline-scroller id="scroller" style="height: 65px;"></taaabs-trace-timeline-scroller>
      <paper-progress id="progress" indeterminate disabled></paper-progress>
      <paper-progress id="background-progress" min="0" max="100" value="0"></paper-progress>
    </div>
  </template>
  <script>
    Polymer({
      is: 'taaabs-trace-timeline-container',

      properties: {

        /**
         * The trace.
         *
         * @attribute trace
         * @type Object
         */
        trace: {
          type: Object,
          value: null
        },

        /**
         * The trace URI.
         *
         * @attribute traceUri
         * @type String
         */
        traceUri: {
          type: String,
          value: null
        },

        /**
         * The trace stats.
         *
         * @attribute traceStats
         * @type String
         */
        traceStats: {
          type: String,
          value: null
        },

        /**
         * Begin time of the current interval.
         *
         * @attribute _currentBegin
         * @type Number
         */
        _currentBegin: {
          type: Number,
          value: 0
        },

        /**
         * End time of the current interval.
         *
         * @attribute _currentEnd
         * @type Number
         */
        _currentEnd: {
          type: Number,
          value: 0
        },

        /**
         * Either 'FIRST', 'BEFORE' or 'AFTER'.
         *
         * @attribute _downloadType
         * @type String
         */
        _downloadType: {
         type: String,
         value: ""
        },

        /**
         * True if `timeline-scroller-new-bounds` is already listened. False otherwise.
         *
         * @attribute _isEventListened
         * @type Boolean
         */
        _isEventListened: {
         type: Boolean,
         value: false
        },

        /**
         * List of the loading process waiting to be launched.
         *
         * @attribute _loadingProcessList
         * @type Array
         */
        _loadingProcessList: {
         type: Array,
         value: []
        },

        /**
         * List of the obsels currently downloaded.
         *
         * @attribute _loadingObselsList
         * @type Array
         */
        _loadingObselsList: {
          type: Array,
          value: []
        },

        /**
         * Max time ever downloaded.
         *
         * @attribute _maxEnd
         * @type Number
         */
        _maxEnd: {
          type: Number,
          value: Number.NEGATIVE_INFINITY
        },

        /**
         * Minimum time ever downloaded.
         *
         * @attribute _minBegin
         * @type Number
         */
        _minBegin: {
          type: Number,
          value: Number.POSITIVE_INFINITY
        },

        /**
         * List of the obsels.
         *
         * @attribute _obselsList
         * @type Array
         */
        _obselsList: {
          type: Array,
          value: []
        },

        /**
         * End of the second part of obsels to download.
         *
         * @attribute _secondPartEnd
         * @type Number
         */
        _secondPartEnd: {
          type: Number,
          value: 0
        },


        /**
        * TRYHARD *
        */

        _downloadBuffer: {
          type: Array,
          value: []
        },

        _downloadPriority: {
          type: Array,
          value: []
        },

        _obselsCount: {
          type: Number,
          value: 0
        }


      },

      attached: function() {
        if(!this._isEventListened){
          this.$.scroller.addEventListener('timeline-scroller-new-bounds', this._onTimelineScrollerNewBounds.bind(this));
          this.$.scroller.addEventListener('timeline-scroller-shift', this._onTimelineScrollerShift.bind(this));
          this.$.timeline.addEventListener('timeline-interval-selected', this._onTimelineIntervalSelected.bind(this));
          this.set('_isEventListened', true);
        }
      },

      ready: function() {},

      /**
       * Redraw the obsels with every obsel between `_currentBegin` and `_currentEnd`.
       *
       * @method updateTimeline
       */
      updateTimeline: function(){
        this.$.timeline.redrawObsels(this._applyStyleOnObsels(this._getObselsForCurrentBounds()));
      },

      /**
       * Reset the timeline and the scroller.
       *
       * @method refresh
       */
      refresh: function(){
        // Get the begin and end of the trace.
        var b = this.traceStats['stats:minTime'];
        var e = this.traceStats['stats:maxTime'];
        this.set('_currentBegin', b);
        this.set('_currentEnd',   e);
        // Set the scroller vars.
        this.$.scroller.init(b, e);
        // Set the timeline vars
        this.$.timeline.setTemporalBounds(b, e);
        this.$.timeline.initVisu();
        // While the timeline width isn't set, we wait.
        // Then, we start the passiv download
        var interval = setInterval(function(){
          if(this.$.timeline._width !== 0){
            clearInterval(interval);
            this._startPassiveDownload();
          }
        }.bind(this), 500);
      },

      /**
       * Create the `_downloadBuffer` for every column of obsel.
       * Calls `_launchDownload`.
       *
       * @method _startPassiveDownload
       */
      _startPassiveDownload: function(){
        // Get the begin/end of the trace.
        // Calculate the period for each obsel column
        var b = this.traceStats['stats:minTime'];
        var e = this.traceStats['stats:maxTime'];
        var c = this.$.timeline._width / (this.$.timeline._obselWidth + 2);
        var period = Math.ceil((e-b) / c);
        this.set('_downloadPeriod', period);
        // Create a download buffer for each column
        for(var i = 0 ; i < c ; i++){
          this.push('_downloadBuffer', {
            'b': b+(period*i),
            'e': b+(period*i)+period,
            'isOver': false,
            'obsels': []
          });
        }
        // Start the download
        this._launchDownload();
      },

      /**
       * Start a download of obsels. If there are some priority downlaod to do, download them first.
       *
       * @method _launchDownload
       */
      _launchDownload: function(){
        // If we don't have priority downloads, we download every obsel in background.
        if(this._downloadPriority.length === 0){
          this.$.progress.set('disable', true);
          // Show the passive progress bar.
          var i = 0;
          // If the first download campaign is over, we look for the column not complete yet.
          // Otherwise, we look for the column visited yet.
          // When the first campaign is over , we set `_firstDownloadDone` to true, and we _launchDownload again.
          if(this._firstDownloadDone){
            while(i < this._downloadBuffer.length &&
              this._downloadBuffer[i].isOver) i++;
          }
          else{
            while(i < this._downloadBuffer.length &&
              ( this._downloadBuffer[i].isOver || this._downloadBuffer[i].obsels.length !== 0 ))
              i++;
            if(i >= this._downloadBuffer.length){
              this._firstDownloadDone = true;
              this._launchDownload();
            }
          }
          // If we havan't download everyhing yet, well, we get the obsels...
          if(i < this._downloadBuffer.length){
            this.set('_downloadCurrentBufferIndex', i);
            // Set time
            var b = this.traceStats['stats:minTime'];
            b += (i * this._downloadPeriod);
            // Set obsel
            var uri = null;
            if(this._downloadBuffer[i].obsels.length > 0) uri = this._downloadBuffer[i].obsels[this._downloadBuffer[i].obsels.length - 1]['@id'];
            if(this._firstDownloadDone)
              this._downloadObsels(b, b + this._downloadPeriod - 1, 100, uri );
            else
              this._downloadObsels(b, null, 30, uri );
          }
        }
        else{
          this.$.progress.set('disable', false);
          var i = this.splice('_downloadPriority', 0, 1);
          while(this._downloadBuffer[i].isOver)
            i = this.splice('_downloadPriority', 0, 1);
          this.set('_downloadCurrentBufferIndex', i);
          // Set time
          var b = this.traceStats['stats:minTime'];
          b += (i * this._downloadPeriod);
          // Set obsel
          var uri = null;
          if(this._downloadBuffer[i].obsels.length > 0) uri = this._downloadBuffer[i].obsels[this._downloadBuffer[i].obsels.length - 1]['@id'];
          this._downloadObsels(b, b + this._downloadPeriod - 1, 100, uri );
        }
      },

      /**
       * Download the obsels.
       *
       * @param {!optionnal} start (Number) The begin time of the interval to download.
       * @param {!optionnal} stop (Number) The end time of the interval to download.
       * @param {!optionnal} limit (Number) Max count of obsel to download.
       * @param {!optionnal} uri (Number) Uri of the start obsel.
       *
       * @method _downloadObsels
       */
      _downloadObsels: function(start, stop, limit, uri){
        limit = limit || 100;
        var minb  = (start) ? 'minb='+start  : '';
        var maxe  = (stop)  ? '&maxe='+stop  : '';
        var after = (uri)   ? '&after='+uri   : '';
        var request = this.traceUri + '@obsels?'+minb+after+maxe+'&limit='+limit;
        var XMLReq = new XMLHttpRequest();
        XMLReq.open("GET", request);
        XMLReq.setRequestHeader('Content-Type', 'application/json');
        XMLReq.setRequestHeader('Accept', 'application/ld+json');
        XMLReq.withCredentials = true;
        XMLReq.onreadystatechange = function() {
         if (XMLReq.readyState === 4) {
           if (XMLReq.status === 200 || XMLReq.status === 201 || XMLReq.status === 304) {
             this._handleDownloadObselResponse(XMLReq.response, limit);
           } else {
             console.log(XMLReq);
           }
         }
        }.bind(this);
        XMLReq.onerror = function(err) {
         console.log(err);
        };
        XMLReq.send(null);
      },

      /**
       * Handle the download response. Sort the obsels in the `_downloadBuffer`.
       * Call `_launchDownload`.
       * Send the obsels to the timeline.
       *
       * @param {!required} response {Object} The response of the query.
       *
       * @method _handleDownloadObselResponse
       */
      _handleDownloadObselResponse: function(response, limit){
        // Parse the obsels array
        var obs = (JSON.parse(response)).obsels;
        // Sort the obsels in the download buffer.
        this._sortObselsInBuffer(obs, (obs.length < limit));
        // Update the background-progress status
        this._updateBackgroundProgress(obs.length);
        // Relaunch the download.
        this._launchDownload();
        // Update the timeline obsels.
        this.$.timeline.addObsels(this._applyStyleOnObsels(obs));
      },

      /**
       * Upadte the `background-progress` status.
       *
       * @param {!required} count {Number} The number of obsels downloaded.
       *
       * @method _updateBackgroundProgress
       */
      _updateBackgroundProgress: function(count) {
        this.set('_obselsCount', this.get('_obselsCount') + count);
        var progress = Math.floor( this.get('_obselsCount') / this.traceStats['stats:obselCount'] * 100 );
        this.$['background-progress'].set('value', progress);
      },


      /**
       * Sort the obsels downloaded ine hte `_downloadBuffer`.
       *
       * @param {!required} obs {Array} List of obsel to sort in the `_downloadBuffer`.
       * @param {!required} overflow {Boolean} True if the request retrieve less obsels than the limit. This would mean that the corresponding obsel column is completly downloaded.
       *
       * @method _sortObselsInBuffer
       */
      _sortObselsInBuffer: function(obs, overflow){
        var index = this.get('_downloadCurrentBufferIndex');
        // For each obsels in obs, if it fit in a column, we add it to the column.
        // If it doesn't fit, we set the column as "over" and increment the column position.
        for(var i = 0; i < obs.length; i++){
          if(obs[i].begin >= this._downloadBuffer[index].b && obs[i].end < this._downloadBuffer[index].e){
            this._downloadBuffer[this._downloadCurrentBufferIndex].obsels.push(obs[i]);
          }
          else{
            i--;
            this._downloadBuffer[index].isOver = true;
            index++;
          }
          // Security condition, to avoid overflow.
          if(index > this._downloadBuffer.length){
            i = obs.length;
          }
        }
        // If we switched of obsel column
        if(index !== this.get('_downloadCurrentBufferIndex')){
          if(overflow) this._downloadBuffer[index].isOver = true;
          if(this._downloadBuffer[index].obsels.length > 30) index++;
          this.set('_downloadCurrentBufferIndex', index);
        }
        else{
          if(overflow) this._downloadBuffer[index].isOver = true;
          this.set('_downloadCurrentBufferIndex', index+1);
        }
      },


      /**
       * Set the symbol of a list of obsels according to the `stylesheet`.
       * TODO: Set default symbol.
       *
       * @param {!required} list (Array) The obsels.
       *
       * @method _applyStyleOnObsels
       */
      _applyStyleOnObsels: function(list){
        var result = [];
        var r = this.stylesheet.rules;
        var t = [];
        // For every obsels, sort the list of rule following :
        // number of type prior number of attribute prior index of rule.
        for(var i = 0; i < list.length; i++){
          t = [];
          var o = {};
          for(var j = 0; j < r.length; j++){
            o = {'id': j.id, 'i': j, 't': 0, 'a': 0};
            var tan = 0;
            for(var k = 0; k < r[j].rules.length; k++){
              var doNotMatch = false;
              if(r[j].rules[k].type !== ""){
                if(list[i]['@type'] === r[j].rules[k].type.replace(this.trace.model_uri+"#", 'm:')){
                  o.t = 1;
                }
                else{
                  doNotMatch = true;
                }
              }
              if(!doNotMatch){
                for(var l = 0; l < r[j].rules[k].attributes.length; l++){
                  if(list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')] !== undefined &&
                  list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')] !== null){
                    switch(r[j].rules[k].attributes[l].operator){
                      case "==":
                        if(list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')] == r[j].rules[k].attributes[l].value){
                          o.a += 1;
                        }
                        else doNotMatch = true;
                      break;
                      case ">":
                        if(Number(list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')]) > Number(r[j].rules[k].attributes[l].value)){
                          o.a += 1;
                        }
                        else doNotMatch = true;
                      break;
                      case ">=":
                        if(Number(list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')]) >= Number(r[j].rules[k].attributes[l].value)){
                          o.a += 1;
                        }
                        else doNotMatch = true;
                      break;
                      case "<":
                        if(Number(list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')]) < Number(r[j].rules[k].attributes[l].value)){
                          o.a += 1;
                        }
                        else doNotMatch = true;
                      break;
                      case "<=":
                        if(Number(list[i][r[j].rules[k].attributes[l].uri.replace(this.trace.model_uri+"#", 'm:')]) <= Number(r[j].rules[k].attributes[l].value)){
                          o.a += 1;
                        }
                        else doNotMatch = true;
                      break;
                    }
                  }
                }
              }
              if(!doNotMatch) t.push(o);
              else{
                t.push({'id': j.id, 'i': j, 't': 0, 'a': 0});
              }
            }
          }
          // Sort the valid symbl list according to their priority.
          // type > attribute > position in rules.
          t.sort(function(a, b) {
            if(a.t === b.t){
              if     (a.a === b.a) return (a.i > b.i) ? 1 : -1;
              else if(a.a > b.a)   return -1;
              else return 1;
            }
            else if(a.t > b.t) return -1;
            else return 1;
          });
          // If the rule as a type and an attribute, we push the obsel to the result list.
          if(t[0].a !== 0 || t[0].t !== 0)[
            result.push({
              'obsel': list[i],
              'symbol': r[t[0].i].symbol,
              'visible': r[t[0].i].visible
            })
          ]
        }
        return result;
      },

      /**
       * Retrieve some obsels from `_downloadBuffer` between a begin time and an end time.
       *
       * @param {!optionnal} b {Number} The begin time of the obsels to retrieve from `_downloadBuffer`.
       * @param {!optionnal} e {Number} The end   time of the obsels to retrieve from `_downloadBuffer`.
       *
       * @method _getObselsForCurrentBounds
       */
      _getObselsForCurrentBounds: function(b, e){
        // Set the begin & end
        b = b || this._currentBegin;
        e = e || this._currentEnd;
        // Get the begin & end index position in the `_downloadBuffer` columns.
        var ib = Math.floor((b-this.traceStats['stats:minTime'])/this._downloadPeriod);
        var eb = Math.ceil((e-this.traceStats['stats:minTime']-this._downloadPeriod+1)/this._downloadPeriod);
        // Fill obs with the matching obsels.
        var obs = [];
        for(var i = ib; i <= eb; i++){
         for(var j = 0; j < this._downloadBuffer[i].obsels.length; j++){
           if(this._downloadBuffer[i].obsels[j].begin >= b && this._downloadBuffer[i].obsels[j].end <= e){
             obs.push(this._downloadBuffer[i].obsels[j])
           }
         }
        }
        return obs;
      },

      /**
       * Check is the columns of `_downloadBuffer` between a begin and an end are already downloaded.
       * Returns an Array of index of the columns which need to be download. The Array is empty if there's no need to download.
       *
       * @param {!required} b {Number} The begin time of the column to check.
       * @param {!required} e {Number} The end   time of the column to check.
       *
       * @method _isNotDownloaded
       */
      _isNotDownloaded: function(b, e){
        // Get the begin & end index position in the `_downloadBuffer` columns.
        var ib = Math.floor((b-this.traceStats['stats:minTime'])/this._downloadPeriod);
        var eb = Math.ceil((e-this.traceStats['stats:minTime']-this._downloadPeriod+1)/this._downloadPeriod);
        // Fill the result Array with the columns not over.
        var result = [];
        for(var i = ib; i <= eb; i++){
          if(!this._downloadBuffer[i].isOver)result.push(i);
        }
        return result;
      },

      /**
       * TODO.
       *
       * @param {!required} evt (Event) The `timeline-scroller-new-bounds` event.
       *
       * @method _onTimelineScrollerNewBounds
       */
      _onTimelineScrollerNewBounds: function(evt){
        var b = ( evt.detail.b < this.traceStats['stats:minTime']) ? this.traceStats['stats:minTime'] : evt.detail.b;
        var e = ( evt.detail.e > this.traceStats['stats:maxTime']) ? this.traceStats['stats:maxTime'] : evt.detail.e;
        this.set('_currentBegin',b);
        this.set('_currentEnd',  e);
        this.$.timeline.setTemporalBounds(b,e);
        this.$.timeline.addObsels(this._applyStyleOnObsels(this._getObselsForCurrentBounds()));
        if(this._isNotDownloaded(b,e).length !== 0){
          this.set('_downloadPriority', this._isNotDownloaded(b,e));
        }
      },

      /**
       * TODO.
       *
       * @param {!required} evt (Event) The `timeline-scroller-new-bounds` event.
       *
       * @method _onTimelineIntervalSelected
       */
      _onTimelineIntervalSelected: function(evt){
        var b = ( evt.detail.b < this.traceStats['stats:minTime']) ? this.traceStats['stats:minTime'] : evt.detail.b;
        var e = ( evt.detail.e > this.traceStats['stats:maxTime']) ? this.traceStats['stats:maxTime'] : evt.detail.e;
        this.set('_currentBegin',b);
        this.set('_currentEnd',  e);
        if(this._isDownloaded(b,e).length === 0){
          this.$.timeline.addObsels(this._applyStyleOnObsels(this._getObselsForCurrentBounds()));
        }
        else{
          this.set('_downloadPriority', this._isNotDownloaded(b,e));
        }
      },


       _loadTimelineScrollerShift: function(process){
         // Set the new bounds
         this.set('_currentBegin', process.overall_begin);
         this.set('_currentEnd',   process.overall_end);
         // Create the process var
         var b = process.shift_begin;
         var e = process.shift_end;
         var d = process.direction;
         // True if we already loaded the obsels. False otherwise.
         var already_loaded =
           ((d === 'left' && this._currentEnd < this._maxEnd) ||
           (d === 'right' && this._currentBegin > this._minBegin));
         // Load the enw obsels if necessary.
         if(already_loaded){
          this.$.timeline.shiftObsels(this._applyStyleOnObsels(this._getObselsForCurrentBounds(b, e)), d);
          this._launchLoadingProcess();
         }
         else{
          this.$.progress.set('disabled', false);
          var start = (d === 'left') ? this._maxEnd : this._currentBegin;
          var end   = (d === 'left') ? this._currentEnd : this._minBegin;
          var type  = (d === 'left') ? 'AFTER' : 'BEFORE';
          this.$.timeline.shiftObsels([], d);
          this.set('_downloadType', type);
          this._downloadObsels(start, end);
         }
       },

       /**
        * .
        *
        * @param {!required} evt {String} The `timeline-scoller-shift` event.
        *
        * @method _onTimelineScrollerShift
        */
      _onTimelineScrollerShift: function(evt) {
        // Push the new loading process in the waiting line.
        this.push('_loadingProcessList', {
          'type'         : 'timeline-scoller-shift',
          'overall_begin': evt.detail.b,
          'overall_end'  : evt.detail.e,
          'shift_begin'  : evt.detail.nb,
          'shift_end'    : evt.detail.ne,
          'direction'    : evt.detail.d
        });
        // Launch the download process.
        if(!this._isProcessLaunched){
          this.set('_isProcessLaunched', true);
          this._launchLoadingProcess();
        }
      },





    });
  </script>
</dom-module>
